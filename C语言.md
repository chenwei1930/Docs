## 1. c语言函数如果不用指针,能不能返回结构体

可以！

可以把struct ABC理解当做一个基本类型char,int等传值调用，【不要】当做是返回局部变量，myfun()函数内生成的局部变量x结构体会在函数结束后被覆盖(函数调用，局部变量在栈内)，myfun()函数定义了【返回值类型】为结构体，所以会把x结构体放到返回值位置(因为函数定义了返回值类型，所以知道返回值大小，不会因为函数结束，栈弹出而消失)，在main内把返回值&quot;赋值&quot;给了.

你理解的结果是完全正确的，但中间过程我不以为然——并不是因为函数写了返回结构体就不会将栈中的结构体实体释放了，而是因为返回语句return x;在函数结束之前执行，return x;把栈中的x拷贝到的相同类型的结构体变量y中(如果没有接收变量就不拷贝)后，栈中的局部结构体同样被释放了，但它的“值”已经一一对应地拷贝到主调函数中的接收变量y中了。

```c
能。主调函数必须用相bai同类型的结构体变量接du收！举例代码如下：
//#include "stdafx.h"//If the vc++6.0, with this line.
#include "stdio.h"
#include "string.h"
struct ABC{
    char name[20];
    int n;
};
struct ABC myfun(void){
    struct ABC x={"Lining",99};//声明一个结构体局zhi部变量x并初始化
    return x;//返回dao局部变量结构体x
}
int main(void){
    struct ABC y=myfun();//声明一个同类型结构体变量y并将函数返回值赋给它
    printf("%s %d\n",y.name,y.n);//打出来看看
    return 0;
}
```

## 2. 同步异步阻塞非阻塞

“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
- 1.同步与异步
同步和异步关注的是**消息通信机制** (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，***调用\*在发出之后，这个调用就直接返回了，所以没有返回结果**。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

- 2. 阻塞与非阻塞
阻塞和非阻塞关注的是**程序在等待调用结果（消息，返回值）时的状态.**

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。